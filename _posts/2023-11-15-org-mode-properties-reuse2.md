
# Table of Contents

<<<<<<< HEAD
1.  [Properties in org-mode](#org12a98fd)
    1.  [Approach 1](#orgc5e5ca8)
    2.  [Approach 2:](#org850f7fb)
    3.  [Approach 3:](#org932ba98)
    4.  [Approach 4:](#orgfe01d85)
    5.  [Approach 5:](#org90d76e1)
    6.  [Approach 6](#org764e75d)
    7.  [Idea 7](#org19739d3)
    8.  [Idea 8](#orga99b9b8)
    9.  [Idea 9](#orgdc1da6c)
    10. [Idea 10](#org73ba5a2)
    11. [Useful links:](#org5d7b49f)



<a id="org12a98fd"></a>
=======
1.  [Properties in org-mode](#org3b44b3f)
    1.  [Approach 1](#orgcf5528b)
    2.  [Approach 2:](#org9d441be)
    3.  [Approach 3:](#org1d04f3a)
    4.  [Approach 4:](#org35fe446)
    5.  [Approach 5:](#org9d07107)
    6.  [Approach 6](#orgf11712b)
    7.  [Idea 7](#orgc237c51)
    8.  [Idea 8](#orgb40a225)
    9.  [Idea 9](#org6749fde)
    10. [Idea 10](#org3324ffc)
    11. [Useful links:](#orgfd0e082)



<a id="org3b44b3f"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

# TODO Properties in org-mode


<<<<<<< HEAD
<a id="orgc5e5ca8"></a>
=======
<a id="orgcf5528b"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 1

Given an org document, I'd like to traverse all headlines of the
given level and extract the headline title, provided that:

1.  Headline title can be generated by inline source blocks that use node properties, and
2.  I don't know beforehand what are the names of the node properties that are going to be used to generate the headline.

For example for the document given below:

    * Section about src_elisp{(org-entry-get nil "Name")} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
    (defun level1-headlines-filter ()
      (setq headline (org-entry-get nil "ITEM"))
      (setq props (org-get-entry))
      (setq string (concat headline "\n" props))
      (setq string (org-export-string-as string 'org t '(:with-toc nil)))
      (setq all (list string)))
    
    (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
    (print HEADLINES-PARSED)
    
    #+end_src

`HEADLINES-PARSED` should contain strings:

    "Section about J.S. Bach"
    "Section about W.A. Moz [[file:///home/mb/org/RDITiT/PrzewodyDoktorskie/Sidor_Kamil (2023)/2. Lista-obecnosci-na-obronie-publicznej.org]] art"

Now the results are:

    "Section about "
    "Section about "


<<<<<<< HEAD
<a id="org850f7fb"></a>
=======
<a id="org9d441be"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 2:

    * Section about src_elisp{(org-entry-get nil "Name")} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
    (defun replace-in-string (what with in)
      (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
    
    (defun level1-headlines-filter ()
      (let (headline props)
        (setq headline (org-entry-get nil "ITEM"))
        (setq props (org-get-entry))
        (setq string (replace-in-string "\n" ""(replace-in-string "* " "" (replace-in-string "=" "" (org-export-string-as (concat "* " headline "\n" props) 'org t '(:with-toc nil))))))
       ))
    
    (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
    (print HEADLINES-PARSED)
    
    #+end_src


<<<<<<< HEAD
<a id="org932ba98"></a>
=======
<a id="org1d04f3a"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 3:

    #+MACRO: mymacro an awesome macro
    #+MACRO: town Boston

    #+INCLUDE: ./mymacros.org
    
    * Section about src_elisp{(org-entry-get nil "Name")} from {{{town}}} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} and {{{mymacro}}} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
      (defun replace-in-string (what with in)
        (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
    
      (defun level1-headlines-filter ()
        (let (headline props)
          (setq headline (org-entry-get nil "ITEM"))
          (setq props (org-get-entry))
          (setq string 
    	    (replace-in-string "\n" "" 
    	    (replace-in-string "* " "" 
    	    (replace-in-string "=" "" 
    	    (org-export-string-as 
    	      (concat "#+INCLUDE: mymacros.org" "\n" 
    		      "* " headline "\n" props) 
    	      'org t '(:with-toc nil))))))
         ))
    
      (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
      (print HEADLINES-PARSED)
    
    #+end_src


<<<<<<< HEAD
<a id="orgfe01d85"></a>
=======
<a id="org35fe446"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 4:

    #+PROPERTY: global-property property Name 

    * Section about src_elisp{(org-entry-get nil "Name")} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} and {{{mymacro}}} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
      (defun replace-in-string (what with in)
        (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
    
      (defun level1-headlines-filter ()
        (let (headline props)
          (setq headline (org-entry-get nil "ITEM"))
          (setq props (org-get-entry))
          (setq string 
    	    (replace-in-string "\n" "" 
    	    (replace-in-string "* " "" 
    	    (replace-in-string "=" "" 
    	    (org-export-string-as 
    	      (concat "#+INCLUDE: mymacros.org" "\n" 
    		      "* " headline "\n" props) 
    	      'org t '(:with-toc nil))))))
         ))
    
      (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
      (print HEADLINES-PARSED)
    
    #+end_src


<<<<<<< HEAD
<a id="org90d76e1"></a>
=======
<a id="org9d07107"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 5:

    :Composer: Vivaldi

    :Town: New York

    * Section about src_elisp{(org-entry-get nil "Name")} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} from src_elisp{(org-entry-get nil "Town")} :this:
    :PROPERTIES:
    #+INCLUDE: myprop1.org
    #+INCLUDE: myprop2.org
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
      (defun replace-in-string (what with in)
        (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
    
      (defun level1-headlines-filter ()
        (let (headline props)
          (setq headline (org-entry-get nil "ITEM"))
          (setq props (org-get-entry))
          (setq string 
    	    (replace-in-string "\n" "" 
    	    (replace-in-string "* " "" 
    	    (replace-in-string "=" "" 
    	    (org-export-string-as 
    	      (concat 
    		      "* " headline "\n" props) 
    	      'org t '(:with-toc nil))))))
         ))
    
      (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
      (print HEADLINES-PARSED)
    
    (print (org-collect-keywords '("TITLE")) )
    (print (org-collect-keywords '("MYOWNKEYWORD")) )
    (print (org-collect-keywords '("PROPERTY")) )
    
    ;; (print "AAA")
    ;; (print org-global-properties)
    
    ;; (setq p (org-element-parse-buffer))
    ;; (print p)
    
    (org-collect-keywords '("MYOWNKEYWORD"))
    
    (print (nth 1 (nth 0 (org-collect-keywords '("MYOWNKEYWORD")))))
    (print (nth 1 (nth 0 (org-collect-keywords '("NEWKEY")))))
    (print (nth 1 (nth 0 (org-collect-keywords '("NEWKEY") nil "globalProps.org"))))
    
    #+end_src


<<<<<<< HEAD
<a id="org764e75d"></a>
=======
<a id="orgf11712b"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Approach 6

    :Composer: Vivaldi

    :Town: New York

    #+MACRO: dateOfMeeting 22.11.2023
    #+MACRO: anotherMacro another Macro

    * Section about src_elisp{(org-entry-get nil "Name")} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} from src_elisp{(org-entry-get nil "Town")} :this:
    :PROPERTIES:
    #+INCLUDE: myprop1.org
    #+INCLUDE: myprop2.org
    :END:
    
    ** Subsection checking if properties included in the node above are still valid - The name of the composer: src_elisp{(org-entry-get nil "Composer")} <- should be here
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
      ; tests
      (setq stri "#+MACRO: macroname value and more")
      (setq firstSpace  (string-match " " stri))
      (print firstSpace)
      (setq propName (substring stri 0 firstSpace))
      (setq propVal  (substring stri (+ firstSpace 1) (length stri) ))
      (print propName)
      (print propVal)
    
    
       (defun macros2properties (inputFile outputFile)
         ;; Parse inputFile in search of lines beginning with #+MACRO: mName mVal
         ;; and transform them into property lines: :mName: mVal
         ;; in the outputFile
    
         (setq splitPos 0) ;; cursor position of split, for each line
         (setq restLine "")
         (setq moreLines t )
    
         ;; open the file
         (find-file inputFile)
         (goto-char (point-min)) ;; needed in case the file is already open.
    
    
         (find-file outputFile)
         (erase-buffer)
         (save-buffer)
         (kill-buffer (current-buffer))
    
         (while moreLines
           (search-forward "#+MACRO: ")
    
           (setq splitPos (1- (point)))
           (beginning-of-line)
           (setq fName (buffer-substring-no-properties (point) splitPos))
           (end-of-line)
    
           (setq restLine (string-trim (buffer-substring-no-properties splitPos (point) )))
    
           (setq firstSpace  (string-match " " restLine))
           (print firstSpace)
           (setq propName (substring restLine 0 firstSpace))
           (setq propVal  (substring restLine (+ firstSpace 1) (length restLine) ))
    
           ;; ;; create the file
           (find-file outputFile)
           (setq outString/property (concat ":" propName ": " propVal "\n"  ) )
           (insert outString/property)
    
           (save-buffer)
           (kill-buffer (current-buffer))
    
           (setq moreLines (= 0 (forward-line 1)))
           )
         )
    
    
      (defun replace-in-string (what with in)
        (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
    
      (defun level1-headlines-filter ()
        (let (headline props)
          (setq headline (org-entry-get nil "ITEM"))
          (setq props (org-get-entry))
          (setq string 
    	    (replace-in-string "\n" "" 
    	    (replace-in-string "* " "" 
    	    (replace-in-string "=" "" 
    	    (org-export-string-as 
    	      (concat 
    		      "* " headline "\n" props) 
    	      'org t '(:with-toc nil))))))
         ))
    
      (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
      (print HEADLINES-PARSED)
    
      (macros2properties "./globalExtMacros.org" "./Output.org")
    
    ;; (setq aa "string")
    ;; (insert (concat ":" aa ":"))
    
    #+end_src


<<<<<<< HEAD
<a id="org19739d3"></a>
=======
<a id="orgc237c51"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Idea 7

    * Section about src_elisp{(org-entry-get nil "Composer")} from src_elisp{(org-entry-get nil "Town")} :this:
    :PROPERTIES:
    :Composer: value1
    :Town: value2
    :END:
    
    ** Subsection checking if properties included in the node above are still valid - The name of the composer: src_elisp{(org-entry-get nil "Composer")} <- should be here
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
      ; tests
    #+end_src


<<<<<<< HEAD
<a id="orga99b9b8"></a>
=======
<a id="orgb40a225"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Idea 8

org-mode exporting macros 

    
    #+MACRO: mymacro 12 cat 23
    
      * Section about src_elisp{(org-entry-get nil "Composer")} from src_elisp{(org-entry-get nil "Town")} :this:
      :PROPERTIES:
      :Composer: value1
      :Town: value2
      :END:
    
      ** Subsection checking if properties included in the node above are still valid - The name of the composer: src_elisp{(org-entry-get nil "Composer")} <- should be here
    
      * Code
      #+begin_src elisp :eval yes :results output :exports both
        ; tests
      #+end_src


<<<<<<< HEAD
<a id="orgdc1da6c"></a>
=======
<a id="org6749fde"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Idea 9

Działa!!!!

    
    #+INCLUDE: ./mymacros.org
    
    * Section about src_elisp{(org-entry-get nil "Name")} from {{{town}}} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} and {{{mymacro}}} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
        (defun replace-in-string (what with in)
          (replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
        (defun remove-text-up-to-asterisk (text)
          "Remove text from the beginning of the line to the first asterisk."
          (when (string-match "\\*" text)
    	(setq text (substring text (match-end 0))))
          text)
    
        (defun level1-headlines-filter ()
          (let (headline props)
    	(setq headline (org-entry-get nil "ITEM"))
    	(setq props (org-get-entry))
    	(setq string 
    	      (string-trim ;replace-in-string "\n" "" 
    		;(replace-in-string "* " "" 
    		(remove-text-up-to-asterisk
    		(replace-in-string "=" "" 
    		(org-export-string-as 
    		  (concat "#+INCLUDE: mymacros.org" "\n" 
    			  "* " headline "\n" props) 
    		  'org t '(:with-toc nil)))))) ;)
    	 ))
    
          (setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
          (print HEADLINES-PARSED)
    
    #+end_src


<<<<<<< HEAD
<a id="org73ba5a2"></a>
=======
<a id="org3324ffc"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Idea 10

Globalne wlasnosci

    
    #+INCLUDE: ./mymacros.org
    #+MACRO: AnotherComposer Vivaldi
    
    * Section about src_elisp{(org-entry-get nil "Name")} from {{{town}}} :this:
    :PROPERTIES:
    :Name:     J.S. Bach
    :END:
    
    * Section about src_elisp{(org-entry-get nil "Composer")} and {{{mymacro}}} :this:
    :PROPERTIES:
    :Composer:     W.A. Mozart
    :END:
    
    * Code
    #+begin_src elisp :eval yes :results output :exports both
    
       (defun replace-in-string (what with in)
    	(replace-regexp-in-string (regexp-quote what) with in nil 'literal))
    
       (defun remove-text-up-to-asterisk (text)
    	"Remove text from the beginning of the line to the first asterisk."
    	(when (string-match "\\*" text)
    	  (setq text (substring text (match-end 0))))
    	text)
    
       (defun level1-headlines-filter ()
    	(let (headline props)
    	  (setq headline (org-entry-get nil "ITEM"))
    	  (setq props (org-get-entry))
    	  (setq string 
    		(string-trim ;replace-in-string "\n" "" 
    		  ;(replace-in-string "* " "" 
    		  (remove-text-up-to-asterisk
    		  (replace-in-string "=" "" 
    		  (org-export-string-as 
    		    (concat "#+INCLUDE: mymacros.org" "\n" 
    			    "* " headline "\n" props) 
    		    'org t '(:with-toc nil)))))) ;)
    	   ))
    
    	(setq HEADLINES-PARSED (org-map-entries #'level1-headlines-filter "LEVEL=1+this") )
    
    	(print HEADLINES-PARSED)
    
    
       (org-entry-get (org-element-at-point) "AnotherComposer")
    #+end_src
    
    * Example
    :PROPERTIES:
    :hellomessage: hello
    :END:
    
    #+NAME: get_property
    #+BEGIN_SRC elisp :var prop=""
    	(org-entry-get nil prop t)
    #+END_SRC
    #+RESULTS: get_property
    
    #+BEGIN_SRC emacs-lisp :noweb yes
    	(print "<<get_property("hellomessage")>>")
    #+END_SRC
    
    #+RESULTS:
    : hello
    
    #+BEGIN_SRC emacs-lisp :noweb yes
    	(print "<<get_property("AnotherComposer")>>")
    #+END_SRC  
    
    #+RESULTS:
    : Vivaldi
    
    A tu przykład użycia inline:
    src_elisp[:noweb yes]{(print "<<get_property("AnotherComposer")>>")} 


<<<<<<< HEAD
<a id="org5d7b49f"></a>
=======
<a id="orgfd0e082"></a>
>>>>>>> 515ffa2caf73a47afcb4c46b239bfea6e4090e3a

## Useful links:

